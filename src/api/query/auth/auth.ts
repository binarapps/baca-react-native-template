/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Generated by orval üç∫
 * Do not edit manually.
 * API
 * API documentation for the starter-kit project in NestJS by BinarApps. The API allows management of users, sessions and offers various functions for logged in users. Contains examples of authentication, authorization, and CRUD for selected resources.
 * OpenAPI spec version: 1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import { customInstance } from '../../axios/custom-instance'
import type { ErrorType, BodyType } from '../../axios/custom-instance'
import type {
  AuthConfirmEmailChangeDto,
  AuthConfirmEmailDto,
  AuthEmailChangeDto,
  AuthEmailLoginDto,
  AuthEntity,
  AuthForgotPasswordDto,
  AuthRegisterLoginDto,
  AuthResendVerificationEmailDto,
  AuthResetPasswordDto,
  AuthUpdateDto,
  ErrorEntity,
  ErrorServerEntity,
  ErrorTooManyRequestsEntity,
  ErrorUnauthorizedEntity,
  ErrorValidationEntity,
  RefreshEntity,
  UserEntity,
} from '../../types'

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1]

/**
 * Logs the user into the system and returns access tokens
 * @summary User Login
 */
export const authControllerLogin = (
  authEmailLoginDto: BodyType<AuthEmailLoginDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthEntity>(
    {
      url: `/api/v1/auth/email/login`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: authEmailLoginDto,
      signal,
    },
    options
  )
}

export const getAuthControllerLoginMutationOptions = <
  TData = Awaited<ReturnType<typeof authControllerLogin>>,
  TError = ErrorType<
    | ErrorUnauthorizedEntity
    | ErrorEntity
    | ErrorValidationEntity
    | ErrorTooManyRequestsEntity
    | ErrorServerEntity
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: BodyType<AuthEmailLoginDto> }, TContext>
  request?: SecondParameter<typeof customInstance>
}) => {
  const mutationKey = ['authControllerLogin']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerLogin>>,
    { data: BodyType<AuthEmailLoginDto> }
  > = (props) => {
    const { data } = props ?? {}

    return authControllerLogin(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: BodyType<AuthEmailLoginDto> },
    TContext
  >
}

export type AuthControllerLoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerLogin>>
>
export type AuthControllerLoginMutationBody = BodyType<AuthEmailLoginDto>
export type AuthControllerLoginMutationError = ErrorType<
  | ErrorUnauthorizedEntity
  | ErrorEntity
  | ErrorValidationEntity
  | ErrorTooManyRequestsEntity
  | ErrorServerEntity
>

/**
 * @summary User Login
 */
export const useAuthControllerLogin = <
  TData = Awaited<ReturnType<typeof authControllerLogin>>,
  TError = ErrorType<
    | ErrorUnauthorizedEntity
    | ErrorEntity
    | ErrorValidationEntity
    | ErrorTooManyRequestsEntity
    | ErrorServerEntity
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: BodyType<AuthEmailLoginDto> }, TContext>
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<TData, TError, { data: BodyType<AuthEmailLoginDto> }, TContext> => {
  const mutationOptions = getAuthControllerLoginMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * Registers a new user with email and password
 * @summary User Registration
 */
export const authControllerRegister = (
  authRegisterLoginDto: BodyType<AuthRegisterLoginDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<UserEntity>(
    {
      url: `/api/v1/auth/email/register`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: authRegisterLoginDto,
      signal,
    },
    options
  )
}

export const getAuthControllerRegisterMutationOptions = <
  TData = Awaited<ReturnType<typeof authControllerRegister>>,
  TError = ErrorType<void | ErrorValidationEntity | ErrorTooManyRequestsEntity | ErrorServerEntity>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: BodyType<AuthRegisterLoginDto> }, TContext>
  request?: SecondParameter<typeof customInstance>
}) => {
  const mutationKey = ['authControllerRegister']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerRegister>>,
    { data: BodyType<AuthRegisterLoginDto> }
  > = (props) => {
    const { data } = props ?? {}

    return authControllerRegister(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: BodyType<AuthRegisterLoginDto> },
    TContext
  >
}

export type AuthControllerRegisterMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerRegister>>
>
export type AuthControllerRegisterMutationBody = BodyType<AuthRegisterLoginDto>
export type AuthControllerRegisterMutationError = ErrorType<
  void | ErrorValidationEntity | ErrorTooManyRequestsEntity | ErrorServerEntity
>

/**
 * @summary User Registration
 */
export const useAuthControllerRegister = <
  TData = Awaited<ReturnType<typeof authControllerRegister>>,
  TError = ErrorType<void | ErrorValidationEntity | ErrorTooManyRequestsEntity | ErrorServerEntity>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: BodyType<AuthRegisterLoginDto> }, TContext>
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<TData, TError, { data: BodyType<AuthRegisterLoginDto> }, TContext> => {
  const mutationOptions = getAuthControllerRegisterMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * Confirms the user's email address using the provided confirmation hash.
 * @summary Confirm Email
 */
export const authControllerConfirmEmail = (
  authConfirmEmailDto: BodyType<AuthConfirmEmailDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<unknown>(
    {
      url: `/api/v1/auth/email/confirm`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: authConfirmEmailDto,
      signal,
    },
    options
  )
}

export const getAuthControllerConfirmEmailMutationOptions = <
  TData = Awaited<ReturnType<typeof authControllerConfirmEmail>>,
  TError = ErrorType<void | ErrorValidationEntity | ErrorTooManyRequestsEntity | ErrorServerEntity>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: BodyType<AuthConfirmEmailDto> }, TContext>
  request?: SecondParameter<typeof customInstance>
}) => {
  const mutationKey = ['authControllerConfirmEmail']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerConfirmEmail>>,
    { data: BodyType<AuthConfirmEmailDto> }
  > = (props) => {
    const { data } = props ?? {}

    return authControllerConfirmEmail(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: BodyType<AuthConfirmEmailDto> },
    TContext
  >
}

export type AuthControllerConfirmEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerConfirmEmail>>
>
export type AuthControllerConfirmEmailMutationBody = BodyType<AuthConfirmEmailDto>
export type AuthControllerConfirmEmailMutationError = ErrorType<
  void | ErrorValidationEntity | ErrorTooManyRequestsEntity | ErrorServerEntity
>

/**
 * @summary Confirm Email
 */
export const useAuthControllerConfirmEmail = <
  TData = Awaited<ReturnType<typeof authControllerConfirmEmail>>,
  TError = ErrorType<void | ErrorValidationEntity | ErrorTooManyRequestsEntity | ErrorServerEntity>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: BodyType<AuthConfirmEmailDto> }, TContext>
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<TData, TError, { data: BodyType<AuthConfirmEmailDto> }, TContext> => {
  const mutationOptions = getAuthControllerConfirmEmailMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * Resend the verification email to the user's email address.
 * @summary Resend Verification Email
 */
export const authControllerResendVerificationEmail = (
  authResendVerificationEmailDto: BodyType<AuthResendVerificationEmailDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<unknown>(
    {
      url: `/api/v1/auth/email/resend`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: authResendVerificationEmailDto,
      signal,
    },
    options
  )
}

export const getAuthControllerResendVerificationEmailMutationOptions = <
  TData = Awaited<ReturnType<typeof authControllerResendVerificationEmail>>,
  TError = ErrorType<
    ErrorEntity | ErrorValidationEntity | ErrorTooManyRequestsEntity | ErrorServerEntity
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: BodyType<AuthResendVerificationEmailDto> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}) => {
  const mutationKey = ['authControllerResendVerificationEmail']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerResendVerificationEmail>>,
    { data: BodyType<AuthResendVerificationEmailDto> }
  > = (props) => {
    const { data } = props ?? {}

    return authControllerResendVerificationEmail(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: BodyType<AuthResendVerificationEmailDto> },
    TContext
  >
}

export type AuthControllerResendVerificationEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerResendVerificationEmail>>
>
export type AuthControllerResendVerificationEmailMutationBody =
  BodyType<AuthResendVerificationEmailDto>
export type AuthControllerResendVerificationEmailMutationError = ErrorType<
  ErrorEntity | ErrorValidationEntity | ErrorTooManyRequestsEntity | ErrorServerEntity
>

/**
 * @summary Resend Verification Email
 */
export const useAuthControllerResendVerificationEmail = <
  TData = Awaited<ReturnType<typeof authControllerResendVerificationEmail>>,
  TError = ErrorType<
    ErrorEntity | ErrorValidationEntity | ErrorTooManyRequestsEntity | ErrorServerEntity
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: BodyType<AuthResendVerificationEmailDto> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<
  TData,
  TError,
  { data: BodyType<AuthResendVerificationEmailDto> },
  TContext
> => {
  const mutationOptions = getAuthControllerResendVerificationEmailMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * Initiates the password reset process by sending an email with a reset link to the user's email address.
 * @summary Forgot Password
 */
export const authControllerForgotPassword = (
  authForgotPasswordDto: BodyType<AuthForgotPasswordDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<unknown>(
    {
      url: `/api/v1/auth/forgot/password`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: authForgotPasswordDto,
      signal,
    },
    options
  )
}

export const getAuthControllerForgotPasswordMutationOptions = <
  TData = Awaited<ReturnType<typeof authControllerForgotPassword>>,
  TError = ErrorType<
    ErrorEntity | ErrorValidationEntity | ErrorTooManyRequestsEntity | ErrorServerEntity
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: BodyType<AuthForgotPasswordDto> }, TContext>
  request?: SecondParameter<typeof customInstance>
}) => {
  const mutationKey = ['authControllerForgotPassword']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerForgotPassword>>,
    { data: BodyType<AuthForgotPasswordDto> }
  > = (props) => {
    const { data } = props ?? {}

    return authControllerForgotPassword(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: BodyType<AuthForgotPasswordDto> },
    TContext
  >
}

export type AuthControllerForgotPasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerForgotPassword>>
>
export type AuthControllerForgotPasswordMutationBody = BodyType<AuthForgotPasswordDto>
export type AuthControllerForgotPasswordMutationError = ErrorType<
  ErrorEntity | ErrorValidationEntity | ErrorTooManyRequestsEntity | ErrorServerEntity
>

/**
 * @summary Forgot Password
 */
export const useAuthControllerForgotPassword = <
  TData = Awaited<ReturnType<typeof authControllerForgotPassword>>,
  TError = ErrorType<
    ErrorEntity | ErrorValidationEntity | ErrorTooManyRequestsEntity | ErrorServerEntity
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: BodyType<AuthForgotPasswordDto> }, TContext>
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<TData, TError, { data: BodyType<AuthForgotPasswordDto> }, TContext> => {
  const mutationOptions = getAuthControllerForgotPasswordMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * Resets the user's password using the provided reset password hash.
 * @summary Reset Password
 */
export const authControllerResetPassword = (
  authResetPasswordDto: BodyType<AuthResetPasswordDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<unknown>(
    {
      url: `/api/v1/auth/reset/password`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: authResetPasswordDto,
      signal,
    },
    options
  )
}

export const getAuthControllerResetPasswordMutationOptions = <
  TData = Awaited<ReturnType<typeof authControllerResetPassword>>,
  TError = ErrorType<
    ErrorEntity | ErrorValidationEntity | ErrorTooManyRequestsEntity | ErrorServerEntity
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: BodyType<AuthResetPasswordDto> }, TContext>
  request?: SecondParameter<typeof customInstance>
}) => {
  const mutationKey = ['authControllerResetPassword']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerResetPassword>>,
    { data: BodyType<AuthResetPasswordDto> }
  > = (props) => {
    const { data } = props ?? {}

    return authControllerResetPassword(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: BodyType<AuthResetPasswordDto> },
    TContext
  >
}

export type AuthControllerResetPasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerResetPassword>>
>
export type AuthControllerResetPasswordMutationBody = BodyType<AuthResetPasswordDto>
export type AuthControllerResetPasswordMutationError = ErrorType<
  ErrorEntity | ErrorValidationEntity | ErrorTooManyRequestsEntity | ErrorServerEntity
>

/**
 * @summary Reset Password
 */
export const useAuthControllerResetPassword = <
  TData = Awaited<ReturnType<typeof authControllerResetPassword>>,
  TError = ErrorType<
    ErrorEntity | ErrorValidationEntity | ErrorTooManyRequestsEntity | ErrorServerEntity
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: BodyType<AuthResetPasswordDto> }, TContext>
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<TData, TError, { data: BodyType<AuthResetPasswordDto> }, TContext> => {
  const mutationOptions = getAuthControllerResetPasswordMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * Initiates the process to change the user's email address. After initialization, the user must confirm the email address change through another endpoint.
 * @summary Initialize Email Change
 */
export const authControllerEmailChange = (
  authEmailChangeDto: BodyType<AuthEmailChangeDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<unknown>(
    {
      url: `/api/v1/auth/email/change`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: authEmailChangeDto,
      signal,
    },
    options
  )
}

export const getAuthControllerEmailChangeMutationOptions = <
  TData = Awaited<ReturnType<typeof authControllerEmailChange>>,
  TError = ErrorType<
    ErrorEntity | ErrorValidationEntity | ErrorTooManyRequestsEntity | ErrorServerEntity
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: BodyType<AuthEmailChangeDto> }, TContext>
  request?: SecondParameter<typeof customInstance>
}) => {
  const mutationKey = ['authControllerEmailChange']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerEmailChange>>,
    { data: BodyType<AuthEmailChangeDto> }
  > = (props) => {
    const { data } = props ?? {}

    return authControllerEmailChange(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: BodyType<AuthEmailChangeDto> },
    TContext
  >
}

export type AuthControllerEmailChangeMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerEmailChange>>
>
export type AuthControllerEmailChangeMutationBody = BodyType<AuthEmailChangeDto>
export type AuthControllerEmailChangeMutationError = ErrorType<
  ErrorEntity | ErrorValidationEntity | ErrorTooManyRequestsEntity | ErrorServerEntity
>

/**
 * @summary Initialize Email Change
 */
export const useAuthControllerEmailChange = <
  TData = Awaited<ReturnType<typeof authControllerEmailChange>>,
  TError = ErrorType<
    ErrorEntity | ErrorValidationEntity | ErrorTooManyRequestsEntity | ErrorServerEntity
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: BodyType<AuthEmailChangeDto> }, TContext>
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<TData, TError, { data: BodyType<AuthEmailChangeDto> }, TContext> => {
  const mutationOptions = getAuthControllerEmailChangeMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * Confirms the change of a user's email address using a verification code sent to the new email. This endpoint validates the verification code (hash) received by the user to complete the email address change process.
 * @summary Confirm Email Change
 */
export const authControllerConfirmEmailChange = (
  authConfirmEmailChangeDto: BodyType<AuthConfirmEmailChangeDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<unknown>(
    {
      url: `/api/v1/auth/email/change-confirm`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: authConfirmEmailChangeDto,
      signal,
    },
    options
  )
}

export const getAuthControllerConfirmEmailChangeMutationOptions = <
  TData = Awaited<ReturnType<typeof authControllerConfirmEmailChange>>,
  TError = ErrorType<ErrorEntity | ErrorTooManyRequestsEntity | ErrorServerEntity>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: BodyType<AuthConfirmEmailChangeDto> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}) => {
  const mutationKey = ['authControllerConfirmEmailChange']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerConfirmEmailChange>>,
    { data: BodyType<AuthConfirmEmailChangeDto> }
  > = (props) => {
    const { data } = props ?? {}

    return authControllerConfirmEmailChange(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: BodyType<AuthConfirmEmailChangeDto> },
    TContext
  >
}

export type AuthControllerConfirmEmailChangeMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerConfirmEmailChange>>
>
export type AuthControllerConfirmEmailChangeMutationBody = BodyType<AuthConfirmEmailChangeDto>
export type AuthControllerConfirmEmailChangeMutationError = ErrorType<
  ErrorEntity | ErrorTooManyRequestsEntity | ErrorServerEntity
>

/**
 * @summary Confirm Email Change
 */
export const useAuthControllerConfirmEmailChange = <
  TData = Awaited<ReturnType<typeof authControllerConfirmEmailChange>>,
  TError = ErrorType<ErrorEntity | ErrorTooManyRequestsEntity | ErrorServerEntity>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: BodyType<AuthConfirmEmailChangeDto> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<TData, TError, { data: BodyType<AuthConfirmEmailChangeDto> }, TContext> => {
  const mutationOptions = getAuthControllerConfirmEmailChangeMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * Retrieves information about the current authenticated user
 * @summary Get Current User
 */
export const authControllerMe = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<UserEntity>({ url: `/api/v1/auth/me`, method: 'GET', signal }, options)
}

export const getAuthControllerMeQueryKey = () => {
  return [`/api/v1/auth/me`] as const
}

export const getAuthControllerMeQueryOptions = <
  TData = Awaited<ReturnType<typeof authControllerMe>>,
  TError = ErrorType<ErrorUnauthorizedEntity | ErrorServerEntity>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>>
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAuthControllerMeQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerMe>>> = ({ signal }) =>
    authControllerMe(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authControllerMe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthControllerMeQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerMe>>>
export type AuthControllerMeQueryError = ErrorType<ErrorUnauthorizedEntity | ErrorServerEntity>

export function useAuthControllerMe<
  TData = Awaited<ReturnType<typeof authControllerMe>>,
  TError = ErrorType<ErrorUnauthorizedEntity | ErrorServerEntity>,
>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>> &
    Pick<
      DefinedInitialDataOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>,
      'initialData'
    >
  request?: SecondParameter<typeof customInstance>
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerMe<
  TData = Awaited<ReturnType<typeof authControllerMe>>,
  TError = ErrorType<ErrorUnauthorizedEntity | ErrorServerEntity>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>> &
    Pick<
      UndefinedInitialDataOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>,
      'initialData'
    >
  request?: SecondParameter<typeof customInstance>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerMe<
  TData = Awaited<ReturnType<typeof authControllerMe>>,
  TError = ErrorType<ErrorUnauthorizedEntity | ErrorServerEntity>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>>
  request?: SecondParameter<typeof customInstance>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Current User
 */

export function useAuthControllerMe<
  TData = Awaited<ReturnType<typeof authControllerMe>>,
  TError = ErrorType<ErrorUnauthorizedEntity | ErrorServerEntity>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>>
  request?: SecondParameter<typeof customInstance>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getAuthControllerMeQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Updates information about the current authenticated user
 * @summary Update Current User
 */
export const authControllerUpdate = (
  authUpdateDto: BodyType<AuthUpdateDto>,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<unknown>(
    {
      url: `/api/v1/auth/me`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: authUpdateDto,
    },
    options
  )
}

export const getAuthControllerUpdateMutationOptions = <
  TData = Awaited<ReturnType<typeof authControllerUpdate>>,
  TError = ErrorType<ErrorUnauthorizedEntity | void | ErrorEntity | ErrorServerEntity>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: BodyType<AuthUpdateDto> }, TContext>
  request?: SecondParameter<typeof customInstance>
}) => {
  const mutationKey = ['authControllerUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerUpdate>>,
    { data: BodyType<AuthUpdateDto> }
  > = (props) => {
    const { data } = props ?? {}

    return authControllerUpdate(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: BodyType<AuthUpdateDto> },
    TContext
  >
}

export type AuthControllerUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerUpdate>>
>
export type AuthControllerUpdateMutationBody = BodyType<AuthUpdateDto>
export type AuthControllerUpdateMutationError = ErrorType<
  ErrorUnauthorizedEntity | void | ErrorEntity | ErrorServerEntity
>

/**
 * @summary Update Current User
 */
export const useAuthControllerUpdate = <
  TData = Awaited<ReturnType<typeof authControllerUpdate>>,
  TError = ErrorType<ErrorUnauthorizedEntity | void | ErrorEntity | ErrorServerEntity>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: BodyType<AuthUpdateDto> }, TContext>
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<TData, TError, { data: BodyType<AuthUpdateDto> }, TContext> => {
  const mutationOptions = getAuthControllerUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * Deletes the current authenticated user
 * @summary Delete Current User
 */
export const authControllerDelete = (options?: SecondParameter<typeof customInstance>) => {
  return customInstance<unknown>({ url: `/api/v1/auth/me`, method: 'DELETE' }, options)
}

export const getAuthControllerDeleteMutationOptions = <
  TData = Awaited<ReturnType<typeof authControllerDelete>>,
  TError = ErrorType<ErrorUnauthorizedEntity | ErrorServerEntity>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, void, TContext>
  request?: SecondParameter<typeof customInstance>
}) => {
  const mutationKey = ['authControllerDelete']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerDelete>>,
    void
  > = () => {
    return authControllerDelete(requestOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, void, TContext>
}

export type AuthControllerDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerDelete>>
>

export type AuthControllerDeleteMutationError = ErrorType<
  ErrorUnauthorizedEntity | ErrorServerEntity
>

/**
 * @summary Delete Current User
 */
export const useAuthControllerDelete = <
  TData = Awaited<ReturnType<typeof authControllerDelete>>,
  TError = ErrorType<ErrorUnauthorizedEntity | ErrorServerEntity>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, void, TContext>
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<TData, TError, void, TContext> => {
  const mutationOptions = getAuthControllerDeleteMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * Refreshes the access token using the refresh token
 * @summary Refresh Access Token
 */
export const authControllerRefresh = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<RefreshEntity>(
    { url: `/api/v1/auth/refresh`, method: 'POST', signal },
    options
  )
}

export const getAuthControllerRefreshMutationOptions = <
  TData = Awaited<ReturnType<typeof authControllerRefresh>>,
  TError = ErrorType<ErrorUnauthorizedEntity | ErrorServerEntity>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, void, TContext>
  request?: SecondParameter<typeof customInstance>
}) => {
  const mutationKey = ['authControllerRefresh']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerRefresh>>,
    void
  > = () => {
    return authControllerRefresh(requestOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, void, TContext>
}

export type AuthControllerRefreshMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerRefresh>>
>

export type AuthControllerRefreshMutationError = ErrorType<
  ErrorUnauthorizedEntity | ErrorServerEntity
>

/**
 * @summary Refresh Access Token
 */
export const useAuthControllerRefresh = <
  TData = Awaited<ReturnType<typeof authControllerRefresh>>,
  TError = ErrorType<ErrorUnauthorizedEntity | ErrorServerEntity>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, void, TContext>
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<TData, TError, void, TContext> => {
  const mutationOptions = getAuthControllerRefreshMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * Logs the user out of the system
 * @summary Logout
 */
export const authControllerLogout = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({ url: `/api/v1/auth/logout`, method: 'POST', signal }, options)
}

export const getAuthControllerLogoutMutationOptions = <
  TData = Awaited<ReturnType<typeof authControllerLogout>>,
  TError = ErrorType<ErrorUnauthorizedEntity | ErrorServerEntity>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, void, TContext>
  request?: SecondParameter<typeof customInstance>
}) => {
  const mutationKey = ['authControllerLogout']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerLogout>>,
    void
  > = () => {
    return authControllerLogout(requestOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, void, TContext>
}

export type AuthControllerLogoutMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerLogout>>
>

export type AuthControllerLogoutMutationError = ErrorType<
  ErrorUnauthorizedEntity | ErrorServerEntity
>

/**
 * @summary Logout
 */
export const useAuthControllerLogout = <
  TData = Awaited<ReturnType<typeof authControllerLogout>>,
  TError = ErrorType<ErrorUnauthorizedEntity | ErrorServerEntity>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, void, TContext>
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<TData, TError, void, TContext> => {
  const mutationOptions = getAuthControllerLogoutMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * Logs the user out of all active sessions to enhance security in case of unauthorized access or when changing sensitive account information like passwords
 * @summary Logout all sessions
 */
export const authControllerLogoutAll = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<unknown>(
    { url: `/api/v1/auth/logout/all`, method: 'POST', signal },
    options
  )
}

export const getAuthControllerLogoutAllMutationOptions = <
  TData = Awaited<ReturnType<typeof authControllerLogoutAll>>,
  TError = ErrorType<ErrorUnauthorizedEntity | ErrorServerEntity>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, void, TContext>
  request?: SecondParameter<typeof customInstance>
}) => {
  const mutationKey = ['authControllerLogoutAll']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerLogoutAll>>,
    void
  > = () => {
    return authControllerLogoutAll(requestOptions)
  }

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, void, TContext>
}

export type AuthControllerLogoutAllMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerLogoutAll>>
>

export type AuthControllerLogoutAllMutationError = ErrorType<
  ErrorUnauthorizedEntity | ErrorServerEntity
>

/**
 * @summary Logout all sessions
 */
export const useAuthControllerLogoutAll = <
  TData = Awaited<ReturnType<typeof authControllerLogoutAll>>,
  TError = ErrorType<ErrorUnauthorizedEntity | ErrorServerEntity>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, void, TContext>
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<TData, TError, void, TContext> => {
  const mutationOptions = getAuthControllerLogoutAllMutationOptions(options)

  return useMutation(mutationOptions)
}
